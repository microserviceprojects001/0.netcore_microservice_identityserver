# 先了解一下最后一个模式，客户端模式，帮我介绍一下原理和流程

📌 客户端模式（Client Credentials Grant）
客户端模式是 OAuth 2.0 的 四种授权模式 之一，适用于机器对机器（M2M）通信，即：
✅ 没有用户参与，客户端自己认证自己并直接获取访问令牌（access token）。
✅ 常用于微服务、API 调用、后台任务、机器对机器（M2M）通信。

📝 1. 客户端模式的原理

- 不涉及用户身份，客户端直接以 自己的身份 请求访问令牌。

- 通过 client_id 和 client_secret 鉴权，获得 access_token。

- 适用于受信任的服务端应用，如：微服务间调用、自动化任务、云服务 API。

🔄 2. 认证流程

```
+--------------+                                       +----------------------+
|              |                                       |                      |
|   Client     |                                       |  Authorization Server |
|              |                                       |                      |
+--------------+                                       +----------------------+
       |                                                         |
       |   1. 发送凭据 (client_id, client_secret)                |
       |   POST /token?grant_type=client_credentials            |
       |                                                         |
       |-------------------------------------------------------->|
       |                                                         |
       |   2. 返回访问令牌 (access_token)                        |
       |   { "access_token": "xyz", "token_type": "bearer" }     |
       |<--------------------------------------------------------|
       |                                                         |
       |   3. 使用 access_token 访问 API                         |
       |   GET /resource HTTP/1.1                                |
       |   Authorization: Bearer xyz                             |
       |-------------------------------------------------------->|
       |                                                         |
       |   4. 服务器校验令牌并返回资源                           |
       |   { "data": "some protected content" }                  |
       |<--------------------------------------------------------|


```

🔍 3. 具体步骤
🔹 (1) 客户端请求访问令牌
客户端向授权服务器发送 POST 请求，包含：

- grant_type=client_credentials

- client_id（客户端 ID）

- client_secret（客户端密钥

```
curl -X POST "https://auth.example.com/oauth/token" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET"

```

🔹 (2) 授权服务器返回 access_token
如果 client_id 和 client_secret 验证通过，授权服务器会返回 access_token：

```
{
  "access_token": "eyJhbGciOiJIUzI1...",
  "token_type": "Bearer",
  "expires_in": 3600
}

```

- access_token：令牌，用于访问受保护资源。

- token_type：通常是 "Bearer"。

- expires_in：令牌有效期（秒）。

🔹 (3) 客户端用 access_token 访问 API
客户端在请求 API 时，需要在 Authorization 头部加上 access_token：

```
curl -X GET "https://api.example.com/resource" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1..."

```

API 服务器验证 access_token 后，返回受保护的资源：

```
{
  "data": "some protected content"
}

```

✅ 4. 客户端模式的适用场景

```
适用场景	             说明
微服务之间的认证	      A 微服务请求 B 微服务的 API，不涉及用户身份
机器对机器（M2M）通信	  服务器端应用访问外部 API，例如 AWS、GitHub API
自动化任务	              定时任务、CI/CD、消息队列等无需用户登录的系统
IoT 设备授权	         设备直接用 client_id 和 client_secret 认证

```

⚠️ 5. 客户端模式的安全性

- 必须保证 client_secret 不能泄露！

  - 不能在前端存 client_secret，否则容易被盗取。

  - 只能在受信任的服务器端应用中使用。

- 应使用 HTTPS 传输

  - 不能用 HTTP 传输 client_secret，否则容易被中间人攻击。

- 可使用 JWT 令牌

  - 令牌可以用 JWT（JSON Web Token），让 API 服务器无需额外查询数据库来验证 access_token。

💡 6. 结论
🔹 客户端模式适用于后端服务间通信，不涉及用户身份认证。
🔹 安全性依赖于 client_secret 保护，必须避免泄露。
🔹 适用于微服务、M2M 认证、自动化任务等场景。

# 一些疑问

## 就是说 客户端模式 这个方式不是拿来 用户登录简书系统用的被

是的，客户端模式（Client Credentials Grant） 不是用来让用户登录简书的，而是用于服务端之间的身份认证。🚀

🚫 为什么客户端模式不适用于用户登录？

- 它是服务对服务的授权方式，不涉及用户身份。

- 用户无法输入用户名密码，也不会进行 OAuth 授权。

- 适用于后端认证，但不适用于用户认证。

## 客户端模式 ，能再帮我举一些实例吗，比方说 你提到的 你的 订单服务 需要访问 用户服务，验证订单归属，能帮我详细说明一下认证 流程吗

🏢 微服务架构中的客户端模式示例
场景：订单服务（order-service）访问用户服务（user-service）验证订单归属

在微服务架构下，订单服务 需要向 用户服务 查询订单归属关系。由于这两个服务都是后端服务，不涉及用户登录，所以适合使用客户端模式（Client Credentials Grant）。

🔑 详细认证流程
📌 角色介绍
1, 认证服务器（Auth Server）：负责颁发令牌（Token）。

2, 订单服务（order-service，客户端）：需要调用用户服务的 API，验证订单归属。

3, 用户服务（user-service，资源服务器）：提供受保护的 API，只有通过认证的服务才能访问。
🛠 步骤解析
🔹 1️⃣ 订单服务向认证服务器请求令牌
订单服务 需要调用 用户服务，但它必须先获取一个访问令牌：

```
POST /oauth/token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id=order-service
&client_secret=order-secret

```

🔹 2️⃣ 认证服务器验证身份并返回令牌
认证服务器检查 client_id 和 client_secret 是否正确，并返回令牌：

```
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}

```

📌 令牌内容：

- access_token：用于访问 API 的令牌。

- token_type：通常是 Bearer，表示使用 HTTP 头部携带令牌。

- expires_in：令牌的有效期（秒）。

🔹 3️⃣ 订单服务使用令牌访问用户服务 API
订单服务 现在可以使用 获取到的令牌 来访问 用户服务，查询订单归属：

```
GET /api/users/123/orders HTTP/1.1
Host: user-service.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

```

🔹 4️⃣ 用户服务验证令牌并返回订单归属信息

    - 用户服务 收到请求后，它需要验证令牌是否有效：

    - 如果令牌有效：返回订单归属信息。

    - 如果令牌无效：返回 401 Unauthorized。

✅ 成功响应（令牌有效）：

```
{
  "user_id": 123,
  "orders": [
    { "order_id": 98765, "status": "completed" }
  ]
}

```

🚫 失败响应（令牌无效）：

```
{
  "error": "unauthorized",
  "message": "Invalid or expired token"
}

```

# 那订单服务，如何知道要获取哪个用户的 呢，这个认证，只需要提供 grant_type=client_credentials

&client_id=order-service
&client_secret=order-secret 吗，我感觉认证不同订单会涉及道不同的用户呀

你的问题很关键！在客户端模式（Client Credentials Grant）下，订单服务（order-service）确实无法直接代表某个用户去访问用户服务（user-service）。因为客户端模式没有用户身份，它只验证了订单服务本身的身份。这就带来了一个核心问题：

💡 订单服务如何知道要查询哪个用户的订单？
📌 方案 1：订单服务接受用户身份信息
流程
1, 前端用户登录（使用授权码模式获取 access_token）。

2, 前端调用订单服务，携带用户的 access_token。

3, 订单服务解析 access_token，获取用户 ID。

4, 订单服务使用自己的客户端凭据（client_credentials）去调用用户服务 API
📌 具体实现
✅ 步骤 1：前端用户登录，获取 access_token
✅ 步骤 2：前端携带用户 access_token 请求订单服务
✅ 步骤 3：订单服务解析 access_token，获取 user_id
✅ 步骤 4：订单服务使用客户端模式请求用户服务
✅ 订单服务可以安全地代表用户查询订单数据！

## 你的意思是说，订单服务能够知道用户的 ID 了，然后用这个用户 ID 返回订单数据

订单服务访问用户服务
订单服务获取到用户的 ID 后，就可以将用户 ID 作为参数，调用 用户服务 的 API 来获取该用户的订单信息。

例如，订单服务向用户服务发送请求：

```
GET /api/users/123/orders
Host: user-service.jianshu.com
Authorization: Bearer service-access-token  # 订单服务的客户端凭证

```

## 一个服务在验证 令牌时候，如何区分是用户登录时候的令牌，还是服务于服务之间的令牌呢

一个服务在验证令牌时，通常通过 令牌的内容（如 sub、aud、grant_type 等字段）来区分是用户令牌（User Token）还是服务令牌（Client Token）。
