1. 安装必要的 NuGet 包
   在 IdentityServer 项目中执行以下命令：

```
dotnet add package IdentityServer4.EntityFramework
dotnet add package Pomelo.EntityFrameworkCore.MySql --version 3.2.7
dotnet add package Microsoft.EntityFrameworkCore.Tools

```

# 重新研究D:\Code\1.microservice\0_1.netcore_microservice_identityserver\0.netcore_microservice_identityserver\MvcCookieAuthSample

把数据库文件，快照，以及迁移文件都删除掉后，重新生成数据库

# 添加迁移（明确指定上下文）

```
dotnet ef migrations add YourMigrationName -c ApplicationDbContext

dotnet ef database update -c ApplicationDbContext
```

会生成表：
AspNetUsers

AspNetRoles

AspNetUserRoles

AspNetUserClaims

AspNetUserLogins

AspNetUserTokens

# 然后执行

```
dotnet ef migrations add InitConfigDb -c PersistedGrantDbContext
dotnet ef migrations add InitPersistedGrantDb -c ConfigurationDbContext

dotnet ef database update --context PersistedGrantDbContext
dotnet ef database update --context ConfigurationDbContext
```

生成的表（默认名称）：

Clients：存储客户端应用信息（ClientId、允许的 Scope、重定向 URI 等）。

ClientSecrets：客户端的密钥。

ClientScopes、ClientGrantTypes、ClientRedirectUris 等关联表。

ApiResources：API 资源。

ApiScopes：API 作用域。

IdentityResources：身份资源（OpenID Connect 标准声明）。

以及相关的关联表（如 ApiResourceScopes、IdentityResourceClaims 等）。

这些表用于存储你在 Config.cs 中定义的静态配置数据。

PersistedGrantDbContext（操作存储）
生成的表：

PersistedGrants：存储授权码、刷新令牌、用户同意记录等动态数据。

DeviceCodes：设备流授权所需的设备码。

# 配置文件加载问题

```
var builder = WebApplication.CreateBuilder(args);
var connectionString1 = builder.Configuration.GetConnectionString("MySQL");
foreach (var kvp in builder.Configuration.AsEnumerable())
```

无论如何都不能加载配置

# 通过输出

```
foreach (var kvp in builder.Configuration.AsEnumerable())
{
    Console.WriteLine($"{kvp.Key}: {kvp.Value}");
}
```

查到
contentRoot: D:\Code\1.microservice\2.netcore_microservice_userService\Contact.API  
和contentRoot: D:\Code\1.microservice\0_1.netcore_microservice_identityserver\0.netcore_microservice_identityserverc  
 的确不同呢，

# 方案

launch.json 这个文件中做下修改
"cwd": "${workspaceFolder}", --> "cwd": "${workspaceFolder}/MVCCookieAuthSample",

# 代码解释

1. AddIdentity<ApplicationUser, ApplicationUserRole>()
   注册 Identity 核心服务，指定自定义的用户类 ApplicationUser 和角色类 ApplicationUserRole（它们继承自 IdentityUser 和 IdentityRole）。

添加了用户管理器（UserManager<ApplicationUser>）、角色管理器（RoleManager<ApplicationUserRole>）、登录管理器（SignInManager<ApplicationUser>）等核心组件到依赖注入容器。

同时配置默认的 Identity 选项（如密码策略、锁定策略等，但具体值可在后续通过 Configure<IdentityOptions> 覆盖）。

2. 配置存储（AddConfigurationStore 和 AddOperationalStore）
   这两行将 IdentityServer 的配置数据和操作数据从内存存储改为数据库存储（通过 Entity Framework Core）。

AddConfigurationStore

用于存储 静态配置数据：客户端（Clients）、API 资源（ApiResources）、API 作用域（ApiScopes）、身份资源（IdentityResources）。

通过 options.ConfigureDbContext 指定使用 SQLite 数据库，并告诉 EF Core 在哪个程序集中查找迁移（MigrationsAssembly）。

这相当于将原本注释掉的 AddInMemoryApiScopes 等方法的配置持久化到数据库中，便于动态管理和跨实例共享。

AddOperationalStore
用于存储 动态运行时数据：授权码（Authorization codes）、刷新令牌（Refresh tokens）、用户同意记录（User consents）、设备码等。

同样配置 SQLite 作为存储，并指定迁移程序集。

注释掉的 EnableTokenCleanup 和 TokenCleanupInterval 用于自动清理过期的令牌，可以按需启用。

3. AddAspNetIdentity<ApplicationUser>()
   将 ASP.NET Core Identity 与 IdentityServer 集成，使用自定义的 ApplicationUser 类（继承自 IdentityUser）作为用户实体。

作用：

允许 IdentityServer 在认证过程中通过 Identity 的 UserManager 和 SignInManager 验证用户凭据、获取用户声明（claims）。

使 IdentityServer 能够利用 Identity 的存储（如 ApplicationDbContext）来管理用户数据，而不是使用内置的测试用户或自定义用户存储。

在登录、注销、用户信息端点等场景中，IdentityServer 会调用 Identity 的服务来完成用户相关的操作。
