# ConfigurationDbContext 和 PersistedGrantDbContext 的理解

```
   // 配置数据存储迁移

    scope.ServiceProvider.GetRequiredService<ConfigurationDbContext>().Database.Migrate();



    // 操作数据存储迁移（你问的代码）

    scope.ServiceProvider.GetRequiredService<PersistedGrantDbContext>().Database.Migrate();

      帮我说明一下，什么叫做  配置数据，什么叫做操作数据
```

```
在 IdentityServer 中，数据库存储分为两类核心数据：

1. 配置数据 (Configuration Data)
    存储位置：ConfigurationDbContext
    内容：
        客户端定义 (Clients)
        身份/API 资源 (IdentityResources, ApiResources)
        作用域 (ApiScopes)
    特点：
    静态配置，变更频率低
示例：Client 的 RedirectUris、AllowedGrantTypes
2. 操作数据 (Operational Data)
    存储位置：PersistedGrantDbContext
    内容：
        授权码 (AuthorizationCodes)
        刷新令牌 (RefreshTokens)
        引用令牌 (ReferenceTokens)
        用户同意记录 (PersistedGrants)
    特点：
    动态生成，高频读写
    短期有效（需定期清理）
```

# 上下文参数的指定

```
  14. EFCore数据库更新流程.md
  这里记录了我当时 做数据库更新时候的一些操作，以及越到的问题，dotnet ef migrations add InitialCreate 其中用到了这个命令，其中你能发现我并没有指定 context参数，但是呢，昨天进行了数据库改动包括Client表，IdentityResource 表添加到数据库，应用到了dotnet ef migrations add InitConfigDb -c PersistedGrantDbContext

   dotnet ef migrations add InitPersistedGrantDb -c ConfigurationDbContext 这样的命令就指定了context参数，我之前没指定 Context的命令操作还都成功了，请问这是为什么呢
```

1. 未指定 Context 仍能工作的场景
   当项目中 只有一个 DbContext 时，EF Core 会自动识别并应用迁移，无需显式指定 -c
2. 必须指定 Context 的场景
   当项目包含 多个 DbContext（如 IdentityServer 的
   ConfigurationDbContext
   和 PersistedGrantDbContext），必须明确指定目标上下文：

```
好，那就是说我现在如果要去更新ApplicationUser表的字段信息，那我就需要显示指定context参数了吗 ApplicationDbContext

```

是的，为了明确性和避免歧义（尤其在多 DbContext 项目中），建议始终显式指定 -c ApplicationDbContext。以下是标准操作格式：

```

# 添加迁移（明确指定上下文）
dotnet ef migrations add YourMigrationName -c ApplicationDbContext

# 应用迁移
dotnet ef database update -c ApplicationDbContext
```

# DesignTimeDbContextFactory.cs 这个类什么作用呢

```
DesignTimeDbContextFactory
 是 EF Core 的设计时工具类，主要用于 生成数据库迁移文件时提供 DbContext 实例。以下是其核心作用：

1. 主要功能
在运行 dotnet ef migrations add 时，为 EF Core 工具提供如何构造
ApplicationDbContext的指导

独立于应用程序的运行时依赖注入系统
```

如果还有自定义的 另一个数据库，比方说是 123.db，那就是说还需要另一个 Factory 吗？

```
是的，每个独立的数据库（DbContext）都需要自己的
DesignTimeDbContextFactory
。
以下是多数据库配置示例：
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;

namespace MvcCookieAuthSample.Data
{
    public class DesignTimeDb2Factory : IDesignTimeDbContextFactory<YourSecondDbContext>
    {
        public YourSecondDbContext CreateDbContext(string[] args)
        {
            var options = new DbContextOptionsBuilder<YourSecondDbContext>()
                .UseSqlite("Data Source=123.db")
                .Options;
            return new YourSecondDbContext(options);
        }
    }
}
```

# 何时被调用？

那这个是 Factory 是 什么时候被调用的吗 ，# 为 ApplicationDbContext 生成迁移

dotnet ef migrations add Migration1 -c ApplicationDbContext

# 为 YourSecondDbContext 生成迁移

dotnet ef migrations add Migration2 -c YourSecondDbContext 执行这命令时候吗

```
是的，
DesignTimeDbContextFactory
 会在执行 dotnet ef migrations add 命令时被自动调用。具体触发时机如下：
关键点
    仅设计时：仅在生成迁移时调用，不影响运行时
    自动发现：EF Core 会查找实现 IDesignTimeDbContextFactory<T> 的类
    每个上下文独立：不同 DbContext 的迁移命令会调用对应的 Factory
```
