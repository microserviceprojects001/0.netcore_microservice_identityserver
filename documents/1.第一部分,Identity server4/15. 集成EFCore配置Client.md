# 代码做出了一些修改

```
// .AddInMemoryApiScopes(Config.GetApiScopes())

// .AddInMemoryClients(Config.GetClients())

// .AddInMemoryIdentityResources(Config.GetIdentityResources()) 注释掉这些代码，然后添加了 AddConfigurationStore 和 AddOperationalStore ，我想首先理解一下这个代码的作用
```

修改后的代码从内存存储 (InMemory) 切换到了数据库存储 (
ConfigurationStore - OperationalStore)，这是 IdentityServer 的持久化配置方式。

1. 配置存储 (AddConfigurationStore)

```
.AddConfigurationStore(options =>
{
    options.ConfigureDbContext = builder =>
        builder.UseSqlite(connectionString, sql =>
            sql.MigrationsAssembly(typeof(Program).Assembly.FullName));
})
```

作用：将客户端、资源等配置数据存入数据库（替代 AddInMemoryClients/ApiScopes）
存储内容：
Clients
Identity/API Resources
Scopes

2. 操作存储 (AddOperationalStore)

```
.AddOperationalStore(options =>
{
    options.ConfigureDbContext = builder =>
        builder.UseSqlite(connectionString, sql =>
            sql.MigrationsAssembly(typeof(Program).Assembly.FullName));
    // options.EnableTokenCleanup = true; // 自动清理过期令牌
})
```

作用：存储临时操作数据（如授权码、刷新令牌）
存储内容：
授权码 (Authorization Codes)
刷新令牌 (Refresh Tokens)
引用令牌 (Reference Tokens)

3. 对比内存存储
   | 特性 | 内存存储 (InMemory) | 数据库存储 (ConfigurationStore)
   | |--------------------|----------------------------|-----------------------------------
   | | 配置持久化 | 重启后丢失 | 永久保存
   | | 适用环境 | 开发/测试 | 生产环境 | | 动态修改 | 需重新编译 | 可通过数据库实时更新
   | | 性能 | 更高 | 略低（需数据库查询） |

4. 迁移要求

```
   dotnet ef migrations add InitConfigDb -c PersistedGrantDbContext
   dotnet ef migrations add InitPersistedGrantDb -c ConfigurationDbContext

   dotnet ef database update --context PersistedGrantDbContext
   dotnet ef database update --context ConfigurationDbContext
```

此时数据库会得到更新

# 正确工作流

```
  dotnet ef migrations add InitConfigDb -c PersistedGrantDbContext

   dotnet ef migrations add InitPersistedGrantDb -c ConfigurationDbContext

   dotnet ef database update --context PersistedGrantDbContext

   dotnet ef database update --context ConfigurationDbContext 这样的命令行方式，会生成 Migration 和data文件自动生成一些类的操作，  你的意思是这种scope.ServiceProvider.GetRequiredService<PersistedGrantDbContext>().Database.Migrate();

    scope.ServiceProvider.GetRequiredService<ConfigurationDbContext>().Database.Migrate();代码的方式也是一样被，正常也会自动生成类吗

```

首次初始化（必须用命令行）：

dotnet ef migrations add InitConfig -c ConfigurationDbContext
后续更新（可任选）：
开发环境：Database.Migrate()
生产环境：dotnet ef database update

```
就是说数据库结构 包括字段更新，或者表添加等，必须要用命令行例如dotnet ef migrations add InitConfig -c ConfigurationDbContext生成迁移文件，然后呢，剩下代码中可以选Database.Migrate()，或者命令行 dotnet ef database update
```

您总结得非常准确。在 Entity Framework Core 中，数据库结构变更的标准流程如下：

1. 生成迁移文件

```
# 为特定 DbContext 生成迁移

dotnet ef migrations add YourMigrationName -c YourDbContext
```

生成 Migrations/YYYYMMDDHHMMSS_YourMigrationName.cs 文件
包含 Up() 和 Down() 方法定义变更

2. 应用迁移（两种方式任选）
   方式 1：代码中应用

```
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<YourDbContext>();
    db.Database.Migrate(); // 自动应用未执行的迁移
}
```

方式 2：命令行应用

```

# 为特定 DbContext 应用迁移
dotnet ef database update -c YourDbContext
```
