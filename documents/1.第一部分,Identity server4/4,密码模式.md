# 密码模式（Resource Owner Password Credentials Grant, ROPC）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。

在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。

![alt text](<../0.课程截图/第一部分 Identity Server/11，第一部分，密码模式.png>)

它的步骤如下：

（A）用户向客户端提供用户名和密码。

（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。

（C）认证服务器确认无误后，向客户端提供访问令牌。
B 步骤中，客户端发出的 HTTP 请求，包含以下参数：

grant_type：表示授权类型，此处的值固定为"password"，必选项。
username：表示用户名，必选项。
password：表示用户的密码，必选项。
scope：表示权限范围，可选项。
下面是一个例子。

```
     POST /token HTTP/1.1
     Host: server.example.com

     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded

     grant_type=password&username=johndoe&password=A3ddj3w

```

C 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。

```
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }

```

# 具体流程：

1, 前端（浏览器/客户端）

用户在前端输入 用户名 和 密码。
前端将这些数据通过 HTTPS 发送到 后端服务器（微服务）。

2, 后端服务器（Client）

后端服务器收到用户名和密码后，构造 请求，把这些信息发送给 认证服务器（Authorization Server）：

```
POST /oauth/token
Content-Type: application/x-www-form-urlencoded

grant_type=password
client_id=your_client_id
client_secret=your_client_secret
username=user@example.com
password=your_password
scope=read write

```

注意：这里的 client_secret 不能暴露给前端，所以必须由后端来处理。

3, 认证服务器（Authorization Server）

验证 用户名 和 密码 是否正确。
验证 client_id 和 client_secret 是否有效。
通过验证后，返回一个 访问令牌（Access Token）：

```
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVC...",
  "token_type": "Bearer",
  "expires_in": 3600
}

```

4, 后端服务器

拿到 令牌（Access Token） 后，存储到 Session、Redis 或 JWT 中。
返回给前端 Session ID 或 JWT，前端后续请求时携带它。

5, 前端

前端收到 Session ID 或 JWT 后，存储在 Cookie 或 LocalStorage，后续请求 API 时携带它。

## 但是我看你介绍这个流程，我觉得用户名密码模式也是可以的呢，后端得到用户名密码，然后得到令牌，这样不算安全的吗

从技术上讲，密码模式（ROPC）确实是可行的，但它在 OAuth 2.0 标准里被强烈不推荐，主要是因为安全性和适用场景的问题。
1️⃣ 用户需要直接把用户名 & 密码交给后端 → 破坏 OAuth 设计理念

OAuth 2.0 设计的初衷是不让客户端（简书、微服务）接触用户密码。
如果后端存储或传输不当，密码可能会被泄露。
2️⃣ 微服务架构中，后端要存储/传输用户密码，增加安全风险

在微服务架构下，多个后端服务可能需要共享用户身份，但存储和管理密码会增加被攻击的风险。
例如：数据库被攻击 → 用户密码泄露。
3️⃣ 密码模式需要用户长期信任后端

如果你用微信、GitHub、Google 登录，你不会把你的账号密码交给第三方网站，而是授权网站通过 OAuth 登录。
如果某个网站支持密码模式，那它能存你的密码吗？你敢信任吗？
4️⃣ 密码模式不支持多因素认证（MFA）

现代身份验证通常需要 验证码（短信、邮件）、生物识别，但密码模式只能传用户名和密码，无法扩展。
其他模式（授权码模式）支持二次验证（如短信验证码），密码模式不能。

✅ 哪些情况下可以用密码模式？
尽管 ROPC 模式被强烈不推荐，但在少数情况下还是可以考虑使用：

1, 内部应用（Internal Application）
如果你的 OAuth 服务器和所有客户端都是内部系统，并且可以绝对信任后端，可以考虑 ROPC。
例如：企业内部的 ERP、OA、CRM 系统。
2, 无 UI 设备（CLI、IoT）
例如一些命令行工具（CLI）或 IoT 设备，无法跳转到浏览器进行 OAuth 认证。
但是，更推荐使用 Client Credentials 模式 或 设备授权模式。

# 这和 OAuth 2.0 设计的初衷是完全相违背的。OAuth 2.0 设计的目的是让用户只信任微信，而不是信任简书。
