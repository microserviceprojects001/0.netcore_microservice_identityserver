# 绑定关系

namespace MvcCookieAuthSample.Models.Consent;

public class ConsentInputModel
{
public string Button { get; set; }
public IEnumerable<string> ScopesConsented { get; set; }
public bool RememberConsent { get; set; }
public string ReturnUrl { get; set; }
public string Description { get; set; }
}这是一个父类，namespace MvcCookieAuthSample.Models.Consent;

public class ConsentViewModel : ConsentInputModel
{
public string ClientName { get; set; }
public string ClientUrl { get; set; }
public string ClientLogoUrl { get; set; }
public bool AllowRememberConsent { get; set; }

    public IEnumerable<ScopeViewModel> IdentityScopes { get; set; }
    public IEnumerable<ScopeViewModel> ApiScopes { get; set; }

}
这给类继承了 ConsentInputModel，然后在我的视图中

@model MvcCookieAuthSample.Models.Consent.ConsentViewModel
@{
ViewData["Title"] = "consent page";
}

<div class="page-consent">
    
</div> *@
 绑定的是 子类，@model MvcCookieAuthSample.Models.Consent.ConsentViewModel，我可以理解，在这个视图中做的提交 数据post发的应该是 ConsentViewModel 子类实体，但是在处理Consent提交数据时候，用的 
 public async Task<ProcessConsentResult> ProcessConsent(ConsentInputModel model)  是父类，我想问下，这是 mvc的机制吗，

# 如果我不做类的继承呢，public class ConsentViewModel : ConsentInputModel ，ConsentViewModel 中如果需要父类的属性，我在 ConsentViewModel 在写一遍，ConsentInputModel 类不让 ConsentViewModel 继承， 那好，现在 post 回调模型 public async Task<ProcessConsentResult> ProcessConsent(ConsentInputModel model)还能用这个吗

如果取消继承关系，改为在 ConsentViewModel 中直接重复定义 ConsentInputModel 的属性，仍然可以继续使用 ProcessConsent(ConsentInputModel model)，

# 但是 ，视图中绑定的是@model MvcCookieAuthSample.Models.Consent.ConsentViewModel 这个模型，没啥问题哈？

您完全正确！在视图中使用 @model ConsentViewModel 不会影响表单提交到 ConsentInputModel 的参数绑定，这是 ASP.NET Core MVC 设计中的精妙之处

# 哈哈，那就是说，只要有一个 model ，把其中的属性绑定到视图就行，视图层只关注 属性是什么，不关注是什么 Class 跟他做的绑定，另一个 model 只要是有对应上的 属性，就可以使用？

您总结得非常准确！这就是 ASP.NET Core MVC 模型绑定的核心设计思想。视图层只认属性名，不关心具体的类，只要属性名称和类型匹配，任何包含这些属性的模型都能绑定。

只看 HTML 表单字段的 name 属性（由 asp-for 生成）

完全忽略模型类的继承关系或类型声明

自动类型转换（如将字符串 "true" 转为 bool）
