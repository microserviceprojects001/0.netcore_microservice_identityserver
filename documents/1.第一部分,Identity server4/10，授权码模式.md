# 解析授权码流程

![alt text](<../0.课程截图/第一部分 Identity Server/14，第一部分，认证简介.png>)

# 授权码认证流程

![alt text](<../0.课程截图/第一部分 Identity Server/15，第一部分，授权码认证流程.png>)

# 开始创建 新的工程

C:\Code\netcore_microservice

## 遇到问题，

这里老师视频中的工程代码我们是没有的，需要自己构建出来

## 需要一个极简代码结构带 model, view, controller 的

dotnet new install Duende.IdentityServer.Templates

dotnet new list
其中有输出
Duende IdentityServer Quickstart UI (UI assets only) isui [C#] Web/IdentityServer

dotnet new mvc -n MvcCookieAuthSample # 用了这个，去生成 mvc 基本代码结构

对 MvcCookieAuthSample 工程进行一些修改，包括 IdentityServer 基本配置，以及 能够 Debug 代码的关键配置
能够 debug 代码的主要添加是 launch.json 和 tasks.json 的配置

## 需要一个极简代码结构带 model, view, controller 的 mvc client

dotnet new mvc -n MvcClient
dotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect

#

我想理解一下，我以前的 Client 集成 IdentityServer 认证，

```
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "http://localhost:5002";
        //options.requirehttpsmetadata = false;
        options.Audience = "mvc";
        // 手动配置 MetadataAddress，绕过 HTTPS 检查（仅开发环境！）
        options.ConfigurationManager = new ConfigurationManager<OpenIdConnectConfiguration>(
            metadataAddress: "http://localhost:5002/.well-known/openid-configuration",
            configRetriever: new OpenIdConnectConfigurationRetriever(),
            docRetriever: new HttpDocumentRetriever { RequireHttps = false } // 关键设置
        );
        options.TokenValidationParameters = new()
        {

            ValidateIssuer = false,  // 允许 HTTP 开发环境
            ValidateIssuerSigningKey = true,
            ValidateLifetime = true,
            ValidateAudience = true
        };
    });

```

和我现在要加的认证

```

    builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;
})
.AddCookie("Cookies", options =>
{
    options.Cookie.Name = "Cookies";
    options.ExpireTimeSpan = TimeSpan.FromHours(1);
})
.AddOpenIdConnect("OpenIdConnect", options =>
{
    options.SignInScheme = "Cookies"; // 使用 Cookie 进行登录
    options.Authority = "http://localhost:5002"; // HTTP地址
    options.ClientId = "mvc";
    options.ClientSecret = "secret";
    //options.ResponseType = "code";
    options.SaveTokens = true;

    // 关闭HTTPS验证（仅开发环境！）
    options.RequireHttpsMetadata = false; // 关键设置
    options.BackchannelHttpHandler = new HttpClientHandler
    {
        ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
    };

    // 其他配置
    options.TokenValidationParameters = new()
    {
        ValidateIssuer = false, // 开发环境可关闭Issuer验证
        ValidateAudience = true
    };
});

```

有什么不同吗，我不太理解?

你提到的两种认证方式（JwtBearer 和 OpenIdConnect）是 .NET 中两种完全不同的认证模式，适用于不同场景。以下是它们的核心区别和适用场景分析：
🔍 本质区别

```
特性	   JwtBearer 认证                	 OpenIdConnect 认证
协议	   纯 JWT 校验（通常用于 API）	      OIDC 协议（带完整身份认证流程）
交互方式	无界面跳转，直接校验令牌	       会跳转到 IdentityServer 登录页
典型用途	WebAPI/服务间通信	              MVC/Razor Pages 等有前端页面的应用
令牌处理	 只验证收到的 Access Token	     自动处理 Code 换 Token 的全流程
Session 管理	无状态	                      通过 Cookie 维护会话

```

🛠️ 你的配置对比分析

1. 旧方案 (JwtBearer)

```
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options => { /* 配置 */ });
```

- 用途：
  适合纯 API 项目，直接验证请求头中的 Bearer Token。

- 特点：

不会自动跳转到登录页

需要手动获取 Token（如通过 /connect/token 端点）

无 Cookie 会话管理

2. 新方案 (OpenIdConnect)

```
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie()
    .AddOpenIdConnect(options => { /* 配置 */ });
```

- 用途：
  适合需要用户交互的 MVC/Razor 应用。

- 特点：

自动跳转到 IdentityServer 登录页

自动完成授权码（Code）换 Token 的流程

使用 Cookie 维持登录状态

支持自动刷新 Token
