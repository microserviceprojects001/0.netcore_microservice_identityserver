# PKCE（RFC 7636）的核心流程是：

1. 客户端生成一个随机字符串 code_verifier。
2. 客户端计算 code_challenge：
   如果使用 S256 方法（推荐），则 code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))。

关键点：这里的 BASE64URL-ENCODE 是一种变体 Base64，与标准 Base64 的区别是：

- 不使用填充字符 =。

- 将标准 Base64 中的 + 替换为 -，将 / 替换为 \_

3. 客户端将 code_challenge 和 code_challenge_method=S256 随授权请求发送。

4. 授权成功后，客户端在换取 Token 时发送原始的 code_verifier。

5. 授权服务器根据存储的 code_challenge_method，对接收到的 code_verifier 执行相同变换，并与存储的 code_challenge 比对。
   ❌ 之前失败的原因
   您的日志显示 code_verifier 从生成到使用完全一致，但 IdentityServer 仍报 invalid_grant，错误描述为“Transformed code verifier does not match code challenge”。这说明 您发送的 code_challenge 与服务器基于接收到的 code_verifier 重新计算出的值不一致。

从您的调试输出可以看到，您生成的 code_challenge 是：

```
Lnrvi8WVkpT7DuPMk7W2lRrT/F9j/rLQupaZpC6lq5c=
```

这个字符串包含 / 字符和末尾的 =，这是标准 Base64 编码的特征。而 PKCE 要求的 BASE64URL-ENCODE 应该将 / 替换为 \_，并去掉填充 =，例如变成：

```
Lnrvi8WVkpT7DuPMk7W2lRrT_F9j_rLQupaZpC6lq5c
```

因此，您之前使用的 codeVerifier.ToSha256() 方法（可能是 IdentityModel 的扩展方法）实际上返回的是标准 Base64，而不是 Base64Url。尽管您保存和发送的 code_verifier 正确，但 code_challenge 编码错误，导致服务器验证失败。
